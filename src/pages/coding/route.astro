---
import Layout from "../../layouts/Layout.astro";

const pageTitle = "Random A→B with Mapbox Isochrones";
const pageDesc = "Pure Mapbox: GL JS + Geocoder + Isochrone + Directions (no React).";
---

<Layout title={pageTitle} description={pageDesc}>
  <!-- Mapbox GL -->
  <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" />
  <script src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>

  <!-- Mapbox Geocoder (must load BEFORE our inline script, no defer!) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mapbox/mapbox-gl-geocoder@5.1.2/dist/mapbox-gl-geocoder.css" />
  <script src="https://cdn.jsdelivr.net/npm/@mapbox/mapbox-gl-geocoder@5.1.2/dist/mapbox-gl-geocoder.min.js"></script>

  <!-- Turf -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js" defer></script>

  <style>
    :root{ --card:#121217; --border:#23242b; --muted:#a5a7ae; --text:#e9eaf0; --accent:#3aa1ff; }
    .wrap{display:grid;gap:16px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:1rem 1.25rem}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .grow{flex:1}
    .map{height:70vh;min-height:420px;border-radius:14px;overflow:hidden;border:1px solid var(--border); position:relative; z-index:0;}
    label{font-size:12px;color:var(--muted)}
    input, select, button{background:#0e0f14;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:10px 12px;font-size:14px}
    input[type="number"]{width:120px}
    button{cursor:pointer}
    button.primary{background:var(--accent);color:#05121f;border-color:transparent;font-weight:600}
    .muted{color:var(--muted)}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid var(--border);border-radius:999px;font-size:12px}
    .small{font-size:12px}
    #geocoder-start .mapboxgl-ctrl-geocoder, #geocoder-end .mapboxgl-ctrl-geocoder { width:100%; max-width:unset; }
  </style>

  <section class="card">
    <div class="row">
      <div id="geocoder-start" class="grow"></div>
      <button id="clear-start">Clear Start</button>
    </div>
    <div class="row" style="margin-top:8px">
      <div id="geocoder-end" class="grow"></div>
      <button id="clear-end">Clear End</button>
    </div>

    <hr style="border:none;border-top:1px solid var(--border);margin:14px 0" />

    <div class="row">
      <div>
        <label for="mode">Mode</label><br />
        <select id="mode">
          <option value="driving">Driving</option>
          <option value="cycling">Cycling</option>
          <option value="running">Walking / Running</option>
        </select>
      </div>
      <div>
        <label for="distance">Target Distance (A→B straight‑line shown for info)</label><br />
        <input id="distance" type="number" min="0.5" step="0.1" value="3" />
      </div>
      <div>
        <label for="unit">Unit</label><br />
        <select id="unit"><option value="mi">mi</option><option value="km">km</option></select>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="btn-a2b">Route A → B</button>
      <button id="btn-iso-a2b" class="primary">Random A → B (Isochrones)</button>
      <span id="status" class="pill muted">Idle</span>
    </div>

    <div style="margin-top:10px" class="small">
      Route distance: <b id="achieved">0.0</b> <span id="achieved-unit">mi</span>
      · Straight‑line A→B: <b id="straight">0.0</b> <span id="straight-unit">mi</span>
      <span id="error" class="muted"></span>
    </div>
  </section>

  <section class="card">
    <div id="map" class="map"></div>
  </section>

  <script is:inline>
    // ====== CONFIG ======
    const MAPBOX_ACCESS_TOKEN = "pk.eyJ1IjoiemFjaHNjaG9seiIsImEiOiJjbWVpZ3BsOWwwMmRlMnBuMThuZmpvdDliIn0.tIhpggDUSt0obHDUyILwhg";
    const ISOCHRONE_BASE = "https://api.mapbox.com/isochrone/v1/mapbox/";
    const MAX_RETRIES = 15;

    // ====== STATE ======
    let map, startLoc=null, endLoc=null, startMarker=null, endMarker=null;
    const SRC_ID="route-src", LINE_ID="route-line", ARROW_ID="route-arrows";

    // ====== BOOT ======
    window.addEventListener('load', () => {
      if (typeof MapboxGeocoder === 'undefined') {
        console.error('MapboxGeocoder plugin not loaded');
        document.getElementById('status').textContent = 'Error: Geocoder plugin not loaded';
        return;
      }
      mapboxgl.accessToken = MAPBOX_ACCESS_TOKEN;

      map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/streets-v12',
        center: [-73.9851, 40.7589],
        zoom: 12
      });
      map.addControl(new mapboxgl.NavigationControl(), 'top-right');

      map.on('load', () => {
        map.getCanvas().style.cursor = 'crosshair';
        map.resize();

        // Geocoder widgets
        const geocoderStart = new MapboxGeocoder({ accessToken: mapboxgl.accessToken, mapboxgl, marker:false, placeholder:"Start: address/place" });
        const geocoderEnd   = new MapboxGeocoder({ accessToken: mapboxgl.accessToken, mapboxgl, marker:false, placeholder:"End: address/place" });
        document.getElementById('geocoder-start').appendChild(geocoderStart.onAdd(map));
        document.getElementById('geocoder-end').appendChild(geocoderEnd.onAdd(map));
        geocoderStart.on('result', (e) => setStart(e.result.center));
        geocoderEnd.on('result',   (e) => setEnd(e.result.center));

        // Click to set start/end
        map.on('click', (e) => {
          const pt=[e.lngLat.lng, e.lngLat.lat];
          if(!startLoc) setStart(pt);
          else if(!endLoc) setEnd(pt);
          else { setStart(pt); clearEnd(); }
        });

        // Buttons
        document.getElementById('clear-start').onclick = clearStart;
        document.getElementById('clear-end').onclick = clearEnd;
        document.getElementById('btn-a2b').onclick = onRouteA2B;
        document.getElementById('btn-iso-a2b').onclick = onRandomA2B_Iso;

        // Try geolocate
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(pos => {
            map.flyTo({ center:[pos.coords.longitude, pos.coords.latitude], zoom:14, speed:1 });
          });
        }
        setStatus('Map ready');
      });
    });

    // ====== UI helpers ======
    function setStatus(text, cls){ const el = document.getElementById('status'); el.textContent = text; el.className = 'pill ' + (cls||'muted'); }
    function showError(msg){ const el = document.getElementById('error'); el.innerHTML = msg ? ' · <span class="bad">'+msg+'</span>' : ''; }
    function setAchieved(meters){
      const unit = document.getElementById('unit').value;
      let val = unit==='mi' ? meters/1609.34 : meters/1000;
      document.getElementById('achieved').textContent = val.toFixed(2);
      document.getElementById('achieved-unit').textContent = unit;
    }
    function setStraightlineMeters(){
      if(!startLoc || !endLoc) { document.getElementById('straight').textContent='0.0'; return; }
      // Turf expects [lng,lat] Features or arrays; units in kilometers
      const km = turf.distance(startLoc, endLoc, {units:'kilometers'});
      const unit = document.getElementById('unit').value;
      const val = unit==='mi' ? km*0.621371 : km;
      document.getElementById('straight').textContent = val.toFixed(2);
      document.getElementById('straight-unit').textContent = unit;
      return km*1000; // meters
    }

    // ====== Map helpers ======
    function setStart(lngLat){
      clearRoute();
      startLoc = lngLat;
      if(startMarker) startMarker.remove();
      startMarker = new mapboxgl.Marker({ color:'red' }).setLngLat(lngLat).addTo(map);
      map.flyTo({ center: lngLat, zoom: 14, speed: 1 });
      setStatus('Start set','good'); setStraightlineMeters();
    }
    function setEnd(lngLat){
      clearRoute();
      endLoc = lngLat;
      if(endMarker) endMarker.remove();
      endMarker = new mapboxgl.Marker({ color:'blue' }).setLngLat(lngLat).addTo(map);
      map.flyTo({ center: lngLat, zoom: 14, speed: 1 });
      setStatus('End set','good'); setStraightlineMeters();
    }
    function clearStart(){
      if(startMarker) startMarker.remove(); startMarker=null; startLoc=null;
      clearRoute(); setStatus('Start cleared'); setStraightlineMeters();
    }
    function clearEnd(){
      if(endMarker) endMarker.remove(); endMarker=null; endLoc=null;
      clearRoute(); setStatus('End cleared'); setStraightlineMeters();
    }
    function clearRoute(){
      showError('');
      if(map?.getLayer(LINE_ID)) map.removeLayer(LINE_ID);
      if(map?.getLayer(ARROW_ID)) map.removeLayer(ARROW_ID);
      if(map?.getSource(SRC_ID)) map.removeSource(SRC_ID);
    }
    function profileForDirections(){
      const m = document.getElementById('mode').value;
      return (m === 'running') ? 'walking' : m; // driving|cycling|walking
    }
    async function drawRoute(routeCoords){
      if(!map.isStyleLoaded()){ await new Promise(res=>map.once('styledata',res)); }
      const data = { type:'Feature', properties:{}, geometry:{ type:'LineString', coordinates: routeCoords } };
      if(!map.getSource(SRC_ID)){
        map.addSource(SRC_ID, { type:'geojson', data });
        map.addLayer({ id:LINE_ID, type:'line', source:SRC_ID, layout:{ 'line-join':'round','line-cap':'round' }, paint:{ 'line-color':'#3aa1ff','line-width':5,'line-opacity':0.9 } });
        map.addLayer({ id:ARROW_ID, type:'symbol', source:SRC_ID, layout:{ 'symbol-placement':'line', 'symbol-spacing':100, 'icon-allow-overlap':true, 'icon-image':'triangle-11', 'icon-size':0.8 } });
      } else {
        map.getSource(SRC_ID).setData(data);
      }
      const b = turf.bbox(data);
      map.fitBounds([[b[0],b[1]],[b[2],b[3]]], { padding: 50 });
    }

    // ====== APIs ======
    async function getIso(centerLngLat, meters){
      // centerLngLat is [lng,lat]
      const url = `${ISOCHRONE_BASE}${profileForDirections()}/${centerLngLat[0]},${centerLngLat[1]}?contours_meters=${Math.floor(meters)}&polygons=true&access_token=${mapboxgl.accessToken}`;
      const res = await fetch(url);
      if(!res.ok) throw new Error('Isochrone fetch failed');
      const json = await res.json();
      const poly = json.features?.[0];
      if(!poly) throw new Error('No isochrone polygon');
      return poly; // GeoJSON Polygon
    }
    function pickRandomVertex(poly){
      const ring = poly?.geometry?.coordinates?.[0];
      if(!ring?.length) throw new Error('Bad isochrone ring');
      const idx = Math.floor(Math.random()*ring.length);
      return ring[idx]; // [lng,lat]
    }
    async function getRoute(points){
      const coordsStr = points.map(p => `${p[0]},${p[1]}`).join(';');
      const url = `https://api.mapbox.com/directions/v5/mapbox/${profileForDirections()}/${coordsStr}?continue_straight=true&alternatives=true&geometries=geojson&access_token=${mapboxgl.accessToken}`;
      const res = await fetch(url);
      if(!res.ok) throw new Error('Directions fetch failed');
      const json = await res.json();
      if(!json.routes?.[0]) throw new Error('No route');
      return json.routes[0];
    }

    // ====== Actions ======
    async function onRouteA2B(){
      if(!startLoc || !endLoc){ setStatus('Pick start and end', 'bad'); return; }
      setStatus('Routing…'); clearRoute();
      try{
        const r = await getRoute([startLoc, endLoc]);
        setAchieved(r.distance);
        await drawRoute(r.geometry.coordinates);
        setStatus('Route ready','good');
      }catch(e){ console.error(e); setStatus('Routing failed','bad'); showError('Directions API error'); }
    }

    // Random A→B via Isochrones (both centered at START):
    //  - r1 ~ U(0.2d, 0.4d), r2 ~ U(0.6d, 0.8d), where d = straight-line A→B
    //  - WP1 random point on Iso(start, r1), WP2 random point on Iso(start, r2)
    //  - Route: start → WP1 → WP2 → end
    // If you prefer WP2 to be sampled around END instead, change "const iso2Center = startLoc;" to "endLoc;".
    async function onRandomA2B_Iso(){
      if(!startLoc || !endLoc){ setStatus('Pick start and end', 'bad'); return; }
      setStatus('Sampling isochrones…'); clearRoute(); showError('');

      // straight-line meters
      const d_m = setStraightlineMeters();
      if(!d_m || d_m <= 0){ setStatus('Bad A→B distance','bad'); return; }

      // draw target %s in meters
      const r1 = randBetween(0.20*d_m, 0.40*d_m);
      const r2 = randBetween(0.60*d_m, 0.80*d_m);

      // choose centers
      const iso1Center = startLoc;
      const iso2Center = endLoc; // <-- set to endLoc if you want WP2 near the end

      let attempts = 0;
      while(attempts <= MAX_RETRIES){
        try{
          const [iso1, iso2] = await Promise.all([ getIso(iso1Center, r1), getIso(iso2Center, r2) ]);
          const wp1 = pickRandomVertex(iso1); // [lng,lat]
          const wp2 = pickRandomVertex(iso2);

          setStatus('Routing…');
          const route = await getRoute([ startLoc, wp1, wp2, endLoc ]);
          setAchieved(route.distance);
          await drawRoute(route.geometry.coordinates);
          setStatus('Random A→B ready','good');
          return;
        }catch(err){
          console.warn('Retrying iso A→B:', err);
          attempts++;
        }
      }
      setStatus('Gave up after retries','bad'); showError('Try a different mode or locations.');
    }

    function randBetween(a,b){ return a + Math.random()*(b-a); }
  </script>
</Layout>

---
import Layout from "../../layouts/Layout.astro";

const pageTitle = "Route — Minimal Working Demo";
const pageDesc = "Mapbox GL + Geocoder + Directions (no React).";
---

<Layout title={pageTitle} description={pageDesc}>
  <!-- Core CSS/JS -->
  <link rel="stylesheet" href="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.css" />
  <script defer src="https://api.mapbox.com/mapbox-gl-js/v3.3.0/mapbox-gl.js"></script>

  <!-- Geocoder plugin: LOAD THIS NON-DEFERRED so MapboxGeocoder exists for our inline script -->
  <link rel="stylesheet" href="https://unpkg.com/@mapbox/mapbox-gl-geocoder@5.1.2/dist/mapbox-gl-geocoder.css" />
  <script src="https://unpkg.com/@mapbox/mapbox-gl-geocoder@5.1.2/dist/mapbox-gl-geocoder.min.js"></script>

  <!-- Turf (defer is fine) -->
  <script defer src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
    :root{ --card:#121217; --border:#23242b; --muted:#a5a7ae; --text:#e9eaf0; --accent:#3aa1ff; }
    .wrap{display:grid;gap:16px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:1rem 1.25rem}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .grow{flex:1}
    .map{height:70vh;min-height:420px;border-radius:14px;overflow:hidden;border:1px solid var(--border); position:relative; z-index:0;}
    button{background:var(--accent);color:#05121f;border:0;border-radius:10px;padding:10px 12px;cursor:pointer;font-weight:600}
    .muted{color:var(--muted)}
    /* Geocoder full-width boxes */
    #geocoder-start .mapboxgl-ctrl-geocoder, #geocoder-end .mapboxgl-ctrl-geocoder { width:100%; max-width:unset; }
  </style>

  <section class="card">
    <div class="row">
      <div id="geocoder-start" class="grow"></div>
      <div id="geocoder-end" class="grow"></div>
      <button id="btn-a2b">Route A → B</button>
    </div>
    <div class="muted" style="margin-top:8px">
      Start = red pin. End = blue pin. Click the map: first click sets start, second sets end (then alternates).
    </div>
    <div style="margin-top:8px" class="muted">Status: <span id="status">Booting…</span></div>
  </section>

  <section class="card">
    <div id="map" class="map"></div>
  </section>

  <script is:inline>
    // ---------- CONFIG ----------
    const MAPBOX_ACCESS_TOKEN = "pk.eyJ1IjoiemFjaHNjaG9seiIsImEiOiJjbWVpZ3BsOWwwMmRlMnBuMThuZmpvdDliIn0.tIhpggDUSt0obHDUyILwhg";

    // ---------- STATE ----------
    let map, startLoc = null, endLoc = null;
    let startMarker = null, endMarker = null;
    const SRC_ID = "route-src", LINE_ID = "route-line";

    // ---------- UTIL ----------
    const setStatus = (msg) => { const el = document.getElementById('status'); if (el) el.textContent = msg; };
    const clearRoute = () => {
      if (map?.getLayer(LINE_ID)) map.removeLayer(LINE_ID);
      if (map?.getSource(SRC_ID)) map.removeSource(SRC_ID);
    };
    async function drawLine(coords){
      // Wait for style readiness before upserting layers
      if (!map.isStyleLoaded()) await new Promise(res => map.once('styledata', res));
      const data = { type:'Feature', properties:{}, geometry:{ type:'LineString', coordinates: coords } };
      if (!map.getSource(SRC_ID)) {
        map.addSource(SRC_ID, { type:'geojson', data });
        map.addLayer({
          id: LINE_ID, type: 'line', source: SRC_ID,
          layout: { 'line-join':'round', 'line-cap':'round' },
          paint:  { 'line-color':'#3aa1ff', 'line-width':5, 'line-opacity':0.9 }
        });
      } else {
        map.getSource(SRC_ID).setData(data);
      }
      const b = turf.bbox(data);
      map.fitBounds([[b[0],b[1]],[b[2],b[3]]], { padding: 50 });
    }

    function setStart(lngLat){
      startLoc = lngLat;
      if (startMarker) startMarker.remove();
      startMarker = new mapboxgl.Marker({ color:'red' }).setLngLat(lngLat).addTo(map);
      setStatus('Start set');
    }
    function setEnd(lngLat){
      endLoc = lngLat;
      if (endMarker) endMarker.remove();
      endMarker = new mapboxgl.Marker({ color:'blue' }).setLngLat(lngLat).addTo(map);
      setStatus('End set');
    }

    // ---------- BOOT ----------
    window.addEventListener('load', () => {
      // Ensure plugin is present
      if (typeof MapboxGeocoder === 'undefined') {
        console.error('MapboxGeocoder plugin failed to load.');
        setStatus('Error: Geocoder plugin not loaded');
        return;
      }

      mapboxgl.accessToken = MAPBOX_ACCESS_TOKEN;
      map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/streets-v12',
        center: [-73.9851, 40.7589],
        zoom: 12
      });
      map.addControl(new mapboxgl.NavigationControl(), 'top-right');

      // Attach everything after the style is loaded
      map.on('load', () => {
        map.getCanvas().style.cursor = 'crosshair';
        map.resize();

        // Geocoders
        const geocoderStart = new MapboxGeocoder({ accessToken: mapboxgl.accessToken, mapboxgl, marker:false, placeholder:"Start: address/place" });
        const geocoderEnd   = new MapboxGeocoder({ accessToken: mapboxgl.accessToken, mapboxgl, marker:false, placeholder:"End: address/place" });
        document.getElementById('geocoder-start').appendChild(geocoderStart.onAdd(map));
        document.getElementById('geocoder-end').appendChild(geocoderEnd.onAdd(map));

        geocoderStart.on('result', (e) => setStart(e.result.center));
        geocoderEnd.on('result',   (e) => setEnd(e.result.center));

        // Click to drop markers (first = start, second = end, then alternate)
        map.on('click', (e) => {
          const pt = [e.lngLat.lng, e.lngLat.lat];
          if (!startLoc || (startLoc && endLoc)) {
            setStart(pt);
            // reset end if starting over
            endLoc = null; if (endMarker) { endMarker.remove(); endMarker = null; }
            clearRoute();
          } else {
            setEnd(pt);
          }
        });

        // Route A→B
        document.getElementById('btn-a2b').addEventListener('click', async () => {
          if (!startLoc || !endLoc) { setStatus('Pick start and end'); return; }
          setStatus('Routing…'); clearRoute();
          try{
            const coordsStr = `${startLoc[0]},${startLoc[1]};${endLoc[0]},${endLoc[1]}`;
            const url = `https://api.mapbox.com/directions/v5/mapbox/driving/${coordsStr}?geometries=geojson&overview=full&access_token=${mapboxgl.accessToken}`;
            const res = await fetch(url);
            if(!res.ok) throw new Error('Directions fetch failed');
            const json = await res.json();
            const route = json.routes?.[0];
            if(!route) throw new Error('No route');
            await drawLine(route.geometry.coordinates);
            setStatus('Route ready');
          } catch (err) {
            console.error(err);
            setStatus('Routing failed');
          }
        });

        // Optional: center on user if available
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(pos => {
            map.flyTo({ center:[pos.coords.longitude, pos.coords.latitude], zoom:14, speed:1 });
          });
        }

        setStatus('Map ready');
      });
    });
  </script>
</Layout>

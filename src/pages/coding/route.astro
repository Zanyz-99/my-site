---
import Layout from "../../layouts/Layout.astro";

const pageTitle = "Random Route Generator (Leaflet + OSM + Isochrones)";
const pageDesc = "Random A→B via isochrones at 33% / 66% of Start–End distance. No React.";
---

<Layout title={pageTitle} description={pageDesc}>
  <!-- Leaflet core -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    defer
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Geocoder control (Nominatim) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css"
  />
  <script
    defer
    src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"
  ></script>

  <!-- Leaflet Routing Machine (OSRM) -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css"
  />
  <script
    defer
    src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"
  ></script>

  <!-- Turf (geometry helpers) -->
  <script defer src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
    :root{ --card:#121217; --border:#23242b; --muted:#a5a7ae; --text:#e9eaf0; --accent:#3aa1ff; }
    .wrap{display:grid;gap:16px}
    .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:1rem 1.25rem}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .grow{flex:1}
    .map{height:70vh;min-height:420px;border-radius:14px;overflow:hidden;border:1px solid var(--border); position:relative; z-index:0;}
    label{font-size:12px;color:var(--muted)}
    input, select, button{background:#0e0f14;color:var(--text);border:1px solid var(--border);border-radius:10px;padding:10px 12px;font-size:14px}
    input[type="number"]{width:120px}
    button{cursor:pointer}
    button.primary{background:var(--accent);color:#05121f;border-color:transparent;font-weight:600}
    .muted{color:var(--muted)}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:8px 10px;border:1px solid var(--border);border-radius:999px;font-size:12px}
    .linkrow{display:flex;align-items:center;gap:10px;margin-top:10px}
    a.buttonlike{display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border-radius:10px;border:1px solid var(--border);text-decoration:none}
    a.buttonlike:hover{border-color:#3aa1ff}
    .small{font-size:12px}
  </style>

  <section class="card">
    <div class="row">
      <div id="geocoder-start" class="grow"></div>
      <button id="clear-start">Clear Start</button>
    </div>
    <div class="row" style="margin-top:8px">
      <div id="geocoder-end" class="grow"></div>
      <button id="clear-end">Clear End</button>
    </div>

    <hr style="border:none;border-top:1px solid var(--border);margin:14px 0" />

    <div class="row">
      <div>
        <label for="distance">Desired Loop Distance</label><br />
        <input id="distance" type="number" min="0.5" step="0.1" value="3" />
      </div>
      <div>
        <label for="unit">Unit</label><br />
        <select id="unit"><option value="mi">mi</option><option value="km">km</option></select>
      </div>
      <div>
        <label for="mode">Mode</label><br />
        <select id="mode">
          <option value="driving">Driving</option>
          <option value="foot">Walking / Running</option>
          <option value="bicycle">Cycling</option>
        </select>
      </div>
    </div>

    <div class="row" style="margin-top:10px">
      <button id="btn-a2b">Route A → B</button>
      <button id="btn-loop" class="primary">Generate Random Loop</button>
      <button id="btn-iso-a2b">Random A → B (Isochrones)</button>
      <button id="btn-iso-loop">Loop (Isochrones)</button>
      <label class="pill" style="gap:8px;margin-left:6px">
        <input type="checkbox" id="use-iso" checked />
        Use Isochrones (Mapbox)
      </label>
      <span id="status" class="pill muted">Idle</span>
    </div>

    <div style="margin-top:10px" class="small">
      Distance achieved: <b id="achieved">0.0</b> <span id="achieved-unit">mi</span>
      <span id="error" class="muted"></span>
    </div>

    <div class="linkrow">
      <a id="gmaps-link" class="buttonlike" href="#" target="_blank" rel="noopener" style="display:none">Open in Google Maps →</a>
      <span id="gmaps-note" class="muted small"></span>
    </div>
  </section>

  <section class="card">
    <div id="map" class="map"></div>
  </section>

  <script is:inline>
    // ====== CONFIG ======
    // Mapbox token ONLY for Isochrone sampling. Leave blank to disable iso features.
    const MAPBOX_ISO_TOKEN = "pk.eyJ1IjoiemFjaHNjaG9seiIsImEiOiJjbWVpZ3BsOWwwMmRlMnBuMThuZmpvdDliIn0.tIhpggDUSt0obHDUyILwhg"; // <- put your Mapbox token here to enable isochrones
    const ISO_ENDPOINT = "https://api.mapbox.com/isochrone/v1/mapbox/";
    const MAX_RETRIES = 20;

    // ====== STATE ======
    let map, startMarker=null, endMarker=null, startLatLng=null, endLatLng=null, routingControl=null;

    // ====== INIT MAP ======
    window.addEventListener('load', () => {
      map = L.map('map');
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap'
      }).addTo(map);

      map.setView([40.7589, -73.9851], 13);

      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(pos => {
          map.setView([pos.coords.latitude, pos.coords.longitude], 14);
        });
      }

      map.on('click', (e) => {
        if (!startLatLng) setStart(e.latlng);
        else if (!endLatLng) setEnd(e.latlng);
        else { setStart(e.latlng); clearEnd(); }
      });

      const gcStart = L.Control.geocoder({ defaultMarkGeocode:false, placeholder:'Start: address/place' }).addTo(map);
      gcStart.on('markgeocode', (e) => setStart(e.geocode.center));
      const gcEnd = L.Control.geocoder({ defaultMarkGeocode:false, placeholder:'End: address/place' }).addTo(map);
      gcEnd.on('markgeocode', (e) => setEnd(e.geocode.center));

      document.getElementById('clear-start').onclick = clearStart;
      document.getElementById('clear-end').onclick = clearEnd;
      document.getElementById('btn-a2b').onclick = routeA2B;
      document.getElementById('btn-loop').onclick = () => {
        if (document.getElementById('use-iso').checked) generateLoopIso(); else generateLoop();
      };
      document.getElementById('btn-iso-a2b').onclick = randomA2B_Iso;
      document.getElementById('btn-iso-loop').onclick = generateLoopIso;
    });

    // ====== UI HELPERS ======
    function setStatus(text, cls){ const el = document.getElementById('status'); el.textContent = text; el.className = 'pill ' + (cls||'muted'); }
    function showError(msg){ document.getElementById('error').innerHTML = msg ? ' · <span class="bad">'+msg+'</span>' : ''; }
    function setAchieved(meters){
      const unit = document.getElementById('unit').value;
      const val = unit === 'mi' ? meters/1609.34 : meters/1000;
      document.getElementById('achieved').textContent = val.toFixed(2);
      document.getElementById('achieved-unit').textContent = unit;
    }
    function hideGmaps(){
      const a = document.getElementById('gmaps-link');
      a.style.display = 'none'; a.href = '#';
      document.getElementById('gmaps-note').textContent = '';
    }
    function metersDesired() {
      const distance = parseFloat(document.getElementById('distance').value);
      const unit = document.getElementById('unit').value;
      return unit === 'mi' ? distance * 1609.34 : distance * 1000;
    }

    // ====== MARKERS ======
    function setStart(latlng){
      clearRoute(); hideGmaps();
      startLatLng = latlng;
      if (startMarker) startMarker.remove();
      startMarker = L.marker(latlng, { title:'Start' }).addTo(map);
      setStatus('Start set', 'good');
    }
    function setEnd(latlng){
      clearRoute(); hideGmaps();
      endLatLng = latlng;
      if (endMarker) endMarker.remove();
      endMarker = L.marker(latlng, { title:'End' }).addTo(map);
      setStatus('End set', 'good');
    }
    function clearStart(){
      if (startMarker) startMarker.remove();
      startMarker = null; startLatLng = null;
      clearRoute(); hideGmaps();
      setStatus('Start cleared');
    }
    function clearEnd(){
      if (endMarker) endMarker.remove();
      endMarker = null; endLatLng = null;
      clearRoute(); hideGmaps();
      setStatus('End cleared');
    }

    // ====== ROUTING (OSRM demo) ======
    function clearRoute(){
      showError('');
      if (routingControl) {
        map.removeControl(routingControl);
        routingControl = null;
      }
    }
    function osrmProfile(){
      const m = document.getElementById('mode').value;
      if (m === 'foot') return 'walking';
      if (m === 'bicycle') return 'cycling';
      return 'driving';
    }
    function routeWithWaypoints(waypoints){
      return new Promise((resolve, reject) => {
        clearRoute();
        routingControl = L.Routing.control({
          waypoints,
          router: L.Routing.osrmv1({
            serviceUrl: 'https://router.project-osrm.org/route/v1',
            profile: osrmProfile(),
          }),
          show: false,
          addWaypoints: false,
          routeWhileDragging: false,
          fitSelectedRoutes: true,
          lineOptions: { addWaypoints:false, styles: [{ color:'#3aa1ff', opacity:0.85, weight:6 }] }
        })
        .on('routesfound', (e) => {
          const r = e.routes?.[0];
          if (!r) { reject(new Error('No route')); return; }
          setAchieved(r.summary.totalDistance);
          resolve(r);
        })
        .on('routingerror', (err) => reject(err))
        .addTo(map);
      });
    }

    async function routeA2B(){
      if (!startLatLng || !endLatLng){ setStatus('Pick start and end', 'bad'); return; }
      setStatus('Routing…'); hideGmaps();
      try { await routeWithWaypoints([ L.latLng(startLatLng), L.latLng(endLatLng) ]); setStatus('Route ready', 'good'); }
      catch (e){ console.error(e); setStatus('Routing failed', 'bad'); showError('OSRM error'); }
    }

    // ====== LOOP (non-iso) ======
    function destPoint(latlng, distanceMeters, bearingDeg){
      const R = 6371000;
      const φ1 = latlng.lat * Math.PI/180;
      const λ1 = latlng.lng * Math.PI/180;
      const θ = bearingDeg * Math.PI/180;
      const δ = distanceMeters / R;
      const φ2 = Math.asin( Math.sin(φ1)*Math.cos(δ) + Math.cos(φ1)*Math.sin(δ)*Math.cos(θ) );
      const λ2 = λ1 + Math.atan2(Math.sin(θ)*Math.sin(δ)*Math.cos(φ1), Math.cos(δ)-Math.sin(φ1)*Math.sin(φ2));
      return L.latLng(φ2*180/Math.PI, λ2*180/Math.PI);
    }
    function gmapsMode(){
      const m = document.getElementById('mode').value;
      if (m === 'bicycle') return 'bicycling';
      if (m === 'foot') return 'walking';
      return 'driving';
    }
    function setGmapsLoopLink(start, wp1, wp2){
      const origin = `${start.lat},${start.lng}`;
      const destination = origin;
      const waypoints = `${wp1.lat},${wp1.lng}|${wp2.lat},${wp2.lng}`;
      const url = `https://www.google.com/maps/dir/?api=1&origin=${encodeURIComponent(origin)}&destination=${encodeURIComponent(destination)}&waypoints=${encodeURIComponent(waypoints)}&travelmode=${gmapsMode()}`;
      const a = document.getElementById('gmaps-link');
      a.href = url; a.style.display = 'inline-flex';
      document.getElementById('gmaps-note').textContent = 'Start → waypoint1 → waypoint2 → Start.';
    }
    async function generateLoop(){
      if (!startLatLng){ setStatus('Pick or geocode a start first', 'bad'); return; }
      setStatus('Generating…'); showError(''); hideGmaps();
      const desired = metersDesired();
      const leg = desired/3;

      let retries = 0;
      while (retries <= MAX_RETRIES){
        try {
          const base = Math.random()*360;
          const wp1 = destPoint(startLatLng, leg, base);
          const wp2 = destPoint(startLatLng, leg, (base+120 + (Math.random()*40-20))%360);
          const r = await routeWithWaypoints([ L.latLng(startLatLng), wp1, wp2, L.latLng(startLatLng) ]);
          const err = Math.abs(r.summary.totalDistance - desired);
          if (err < 800) {
            setStatus('Loop ready', 'good');
            setGmapsLoopLink(startLatLng, wp1, wp2);
            return;
          } else { retries++; }
        } catch(e){ console.warn(e); retries++; }
      }
      setStatus('Gave up after retries', 'bad'); showError('Try a different distance or mode.');
    }

    // ====== ISO HELPERS ======
    function mapboxProfile(){
      const m = document.getElementById('mode').value;
      if (m === 'foot') return 'walking';
      if (m === 'bicycle') return 'cycling';
      return 'driving';
    }
    async function fetchIsochrone(latlng, meters) {
      if (!MAPBOX_ISO_TOKEN) throw new Error('No Mapbox token for isochrones');
      const url = `${ISO_ENDPOINT}${mapboxProfile()}/${latlng.lng},${latlng.lat}?contours_meters=${Math.floor(meters)}&polygons=true&access_token=${MAPBOX_ISO_TOKEN}`;
      const res = await fetch(url);
      if (!res.ok) throw new Error('Isochrone fetch failed');
      const json = await res.json();
      const poly = json.features?.[0];
      if (!poly) throw new Error('Isochrone has no polygon');
      return poly; // GeoJSON Polygon
    }
    function nearestOnIso(poly, targetPt){
      // Snap target to the polygon boundary using polygonToLine + nearestPointOnLine
      const line = turf.polygonToLine(poly); // LineString or MultiLineString
      const snapped = turf.nearestPointOnLine(line, targetPt);
      const [lng, lat] = snapped.geometry.coordinates;
      return L.latLng(lat, lng);
    }

    // ====== RANDOM A → B (ISOCHRONES @ 33% / 66%) ======
    async function randomA2B_Iso(){
      if (!document.getElementById('use-iso').checked) { setStatus('Isochrone toggle is off', 'bad'); return; }
      if (!MAPBOX_ISO_TOKEN){ setStatus('Add Mapbox token for isochrones', 'bad'); return; }
      if (!startLatLng || !endLatLng){ setStatus('Pick start and end', 'bad'); return; }

      setStatus('Computing targets…'); showError(''); hideGmaps();

      // Build a Turf LineString start→end and measure great-circle distance D
      const startPt = turf.point([startLatLng.lng, startLatLng.lat]);
      const endPt   = turf.point([endLatLng.lng, endLatLng.lat]);
      const seg     = turf.lineString([startPt.geometry.coordinates, endPt.geometry.coordinates]);
      const D_km    = turf.length(seg, { units: 'kilometers' });        // great-circle distance in km
      const D_m     = D_km * 1000;

      // Targets at 33% and 66% along the segment (in km)
      const t33 = turf.along(seg, D_km * 0.33, { units: 'kilometers' });
      const t66 = turf.along(seg, D_km * 0.66, { units: 'kilometers' });

      // Isochrone radii: 33% around start, 34% around end (complement of 66%)
      const rStart = 0.33 * D_m;
      const rEnd   = 0.34 * D_m;

      setStatus('Fetching isochrones…');
      try {
        const [isoStart, isoEnd] = await Promise.all([
          fetchIsochrone(startLatLng, rStart),
          fetchIsochrone(endLatLng,   rEnd)
        ]);

        // Snap the target points to their respective isochrone rims
        const wp1 = nearestOnIso(isoStart, t33);
        const wp2 = nearestOnIso(isoEnd,   t66);

        setStatus('Routing…');
        await routeWithWaypoints([ L.latLng(startLatLng), wp1, wp2, L.latLng(endLatLng) ]);
        setStatus('Random A→B (iso 33/66) ready', 'good');
      } catch (e){
        console.error(e);
        setStatus('Iso A→B failed', 'bad');
        showError('Isochrone or OSRM error');
      }
    }

    // ====== LOOP (ISO option: sample two points on start isochrone near 33%/66% along a radial) ======
    async function generateLoopIso(){
      if (!document.getElementById('use-iso').checked) { setStatus('Isochrone toggle is off', 'bad'); return; }
      if (!MAPBOX_ISO_TOKEN){ setStatus('Add Mapbox token for isochrones', 'bad'); return; }
      if (!startLatLng){ setStatus('Pick or geocode a start first', 'bad'); return; }

      setStatus('Generating (iso)…'); showError(''); hideGmaps();
      const desired = metersDesired();
      const leg     = desired/3;

      try{
        // Use leg length for the ring and choose two bearings roughly 0° and 120° away from a random axis,
        // but snap each "ideal" target to the isochrone rim to keep them reachable.
        const iso = await fetchIsochrone(startLatLng, leg);

        const base = Math.random()*360;
        const ideal1 = destPoint(startLatLng, leg, base);
        const ideal2 = destPoint(startLatLng, leg, (base+120 + (Math.random()*40-20))%360);

        const t1 = turf.point([ideal1.lng, ideal1.lat]);
        const t2 = turf.point([ideal2.lng, ideal2.lat]);

        const wp1 = nearestOnIso(iso, t1);
        const wp2 = nearestOnIso(iso, t2);

        const r = await routeWithWaypoints([ L.latLng(startLatLng), wp1, wp2, L.latLng(startLatLng) ]);
        setStatus('Loop (iso) ready', 'good');
        setGmapsLoopLink(startLatLng, wp1, wp2);
      }catch(e){
        console.error(e);
        setStatus('Loop (iso) failed', 'bad');
        showError('Isochrone or OSRM error');
      }
    }
  </script>
</Layout>
